using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using static EntityViews.SourceGenerators.SyntaxNodeHelper;

namespace EntityViews.SourceGenerators;

public class ViewModelTemplate
{
    public static string Build(Compilation compilation, ViewModelAnalysis analysis)
    {
        var viewModelOfSymbol = analysis.FindViewModelOfSymbol(compilation) ??
            throw new Exception($"Unable to find target type {analysis.ViewModelOf}.");

        var ff = viewModelOfSymbol.GetMembers()
           .Where(m => m.Kind == SymbolKind.Property)
           .Cast<IPropertySymbol>()
           .SelectMany(p => p.GetAttributes())
           .ToArray();

        var ignorableByAttribute = viewModelOfSymbol.GetMembers()
            .Where(m => m.Kind == SymbolKind.Property)
            .Cast<IPropertySymbol>()
            .Where(p => p.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() is
                "EntityViews.Attributes.IgnorePropertyAttribute" or "EntityViews.Attributes.IgnoreProperty"))
            .Select(p => p.Name)
            .ToImmutableHashSet();

        var properties = viewModelOfSymbol.GetMembers()
            .Where(m => m.Kind == SymbolKind.Property)
            .Cast<IPropertySymbol>()
            .Where(p =>
                !ignorableByAttribute.Contains(p.Name) &&
                !analysis.Ignore.Contains(p.Name));

        var classDeclaration = analysis.ClassDeclaration;

        return $@"// <auto-generated/>
    #nullable enable

    using System.Runtime.CompilerServices;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    namespace {classDeclaration.GetNameSpace()};

    public partial class {classDeclaration.Identifier} : INotifyPropertyChanged
    {{
        private readonly Dictionary<string, string> _validationErrors = [];

    {properties.Aggregate(string.Empty, (currentString, property) => currentString + property.AsValidableProperty())}

        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        /// Validates the view model and returns true if there are no validation errors.
        /// </summary>
        public bool IsValid()
        {{
            // notify the UI to update and delete the previous error.
            foreach (var error in _validationErrors)
            {{
                _ = _validationErrors.Remove(error.Key);
                OnPropertyChanged($""{{error.Key}}Error"");
                OnPropertyChanged($""{{error.Key}}HasError"");
            }}

            var context = new ValidationContext(this);
            var results = new List<ValidationResult>();
            var isValid = Validator.TryValidateObject(this, context, results, true);

            foreach (var result in results)
            {{
                foreach (var member in result.MemberNames)
                {{
                    // if there is already an error for this member, skip it
                    if (_validationErrors.ContainsKey(member)) continue;

                    _validationErrors[member] = result.ErrorMessage ?? ""Unknown error."";
                    OnPropertyChanged($""{{member}}Error"");
                    OnPropertyChanged($""{{member}}HasError"");
                }}
            }}

            return isValid;
        }}

        protected void SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {{
            field = value;
            OnPropertyChanged(propertyName ?? throw new Exception(""Unable to find property name.""));
        }}

        protected void OnPropertyChanged(string propertyName)
        {{
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }}

        private string GetError(string propertyName)
        {{
            return _validationErrors.TryGetValue(propertyName, out var result)
                ? result
                : string.Empty;
        }}
    }}
    "; ;
    }
}
