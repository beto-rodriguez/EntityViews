using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EntityViews.SourceGenerators.Templates;

public class ViewModelTemplate
{
    public static string Build(
        Compilation compilation, ClassDeclarationSyntax classDeclaration, IEnumerable<IPropertySymbol> properties)
    {
        return $@"// <auto-generated/>
#nullable enable

using System.Runtime.CompilerServices;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

namespace {classDeclaration.GetNameSpace()};

public partial class {classDeclaration.Identifier} : INotifyPropertyChanged
{{
    private readonly Dictionary<string, string> _validationErrors = [];

    {properties.Aggregate(string.Empty, (currentString, property) => currentString + property.AsValidableProperty())}

    public event PropertyChangedEventHandler? PropertyChanged;

    /// <summary>
    /// Validates the view model and returns true if there are no validation errors.
    /// </summary>
    public bool IsValid()
    {{
        // notify the UI to update and delete the previous error.
        foreach (var error in _validationErrors)
        {{
            _ = _validationErrors.Remove(error.Key);
            OnPropertyChanged($""{{error.Key}}Error"");
            OnPropertyChanged($""{{error.Key}}HasError"");
        }}

        var context = new ValidationContext(this);
        var results = new List<ValidationResult>();
        var isValid = Validator.TryValidateObject(this, context, results, true);

        foreach (var result in results)
        {{
            foreach (var member in result.MemberNames)
            {{
                // if there is already an error for this member, skip it
                if (_validationErrors.ContainsKey(member)) continue;

                _validationErrors[member] = result.ErrorMessage ?? ""Unknown error."";
                OnPropertyChanged($""{{member}}Error"");
                OnPropertyChanged($""{{member}}HasError"");
            }}
        }}

        return isValid;
    }}

    protected void SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {{
        field = value;
        OnPropertyChanged(propertyName ?? throw new Exception(""Unable to find property name.""));
    }}

    protected void OnPropertyChanged(string propertyName)
    {{
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }}

    private string GetError(string propertyName)
    {{
        return _validationErrors.TryGetValue(propertyName, out var result)
            ? result
            : string.Empty;
    }}
}}
    ";
    }
}
