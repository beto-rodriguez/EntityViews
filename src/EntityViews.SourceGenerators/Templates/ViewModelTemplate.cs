using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EntityViews.SourceGenerators.Templates;

public class ViewModelTemplate
{
    public static string Build(
        Compilation compilation, ClassDeclarationSyntax classDeclaration, IEnumerable<IPropertySymbol> properties)
    {
        return $@"// <auto-generated/>
#nullable enable

using System.Runtime.CompilerServices;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

namespace {classDeclaration.GetNameSpace()};

public partial class {classDeclaration.Identifier} : INotifyPropertyChanged
{{
    private readonly Dictionary<string, string> _validationErrors = [];
    private bool _isValid = true;

{properties.Aggregate(string.Empty, (currentString, property) => currentString + property.AsValidableProperty())}

    public event PropertyChangedEventHandler? PropertyChanged;

    public event Action<{classDeclaration.Identifier}>? Validating;

    /// <summary>
    /// Validates the view model and returns true if there are no validation errors.
    /// </summary>
    public bool IsValid()
    {{
        // notify the UI to update and delete the previous error.
        foreach (var error in _validationErrors)
        {{
            _ = _validationErrors.Remove(error.Key);
            OnPropertyChanged($""{{error.Key}}Error"");
            OnPropertyChanged($""{{error.Key}}HasError"");
        }}

        var context = new ValidationContext(this);
        var results = new List<ValidationResult>();
        _ = Validator.TryValidateObject(this, context, results, true);

        _isValid = true;

        foreach (var result in results)
            foreach (var member in result.MemberNames)
                AddValidationError(member, result.ErrorMessage ?? ""Unknown error."");

        Validating?.Invoke(this);

        return _isValid;
    }}

    public void AddValidationError(string propertyName, string errorMessage)
    {{
        // if there is already an error for this member, skip it
        if (_validationErrors.ContainsKey(propertyName)) return;

        _validationErrors[propertyName] = errorMessage;
        OnPropertyChanged($""{{propertyName}}Error"");
        OnPropertyChanged($""{{propertyName}}HasError"");
        _isValid = false;
    }}

    protected void SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {{
        field = value;
        OnPropertyChanged(propertyName ?? throw new Exception(""Unable to find property name.""));
    }}

    protected void OnPropertyChanged(string propertyName)
    {{
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }}

    private string GetError(string propertyName)
    {{
        return _validationErrors.TryGetValue(propertyName, out var result)
            ? result
            : string.Empty;
    }}
}}
    ";
    }
}
