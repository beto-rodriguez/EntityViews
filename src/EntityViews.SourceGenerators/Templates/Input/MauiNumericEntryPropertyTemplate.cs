namespace EntityViews.SourceGenerators.Templates.Input;

public class MauiNumericEntryPropertyTemplate
{
    public static string Build(InputTemplateParams p)
    {
        var property = p.Property;
        var viewModelName = p.ViewModelName;
        var viewModelNamespace = p.ViewModelNamespace;
        var formNamespace = p.FormNamespace;
        var propertyDisplaySource = p.PropertyDisplaySource;

        return @$"// <auto-generated/>
#nullable enable

using CommunityToolkit.Maui.Markup;
using {viewModelNamespace};

namespace {formNamespace};

public class {property.Name}Input : StackLayout
{{
    private readonly Entry _input;
    private {viewModelName}? _subscribedTo;

    public {property.Name}Input()
    {{
        var label = new {Controls.GetDisplayClassName()}();
        {Controls.GetDisplayRef("label")}.Text({propertyDisplaySource});

        var inputControl = new {Controls.GetTextInputClassName()}();
        _input = {Controls.GetTextInputRef("inputControl")};
        _input.Bind(
            Entry.TextProperty,
            getter: static ({viewModelName} vm) => vm.{property.Name},
            setter: static ({viewModelName} vm, {property.Type.Name} value) => vm.{property.Name} = value);
        _input.Triggers.Add(
            new DataTrigger(typeof(Entry))
            {{
                Binding = new Binding(""{property.Name}HasError""),
                Value = true,
                Setters = {{ new Setter {{ Property = BackgroundColorProperty, Value = {Controls.OnErrorBackgroundColor} }} }},
            }});
        async Task<bool> UserKeepsTyping()
        {{
            var txt = _input.Text;
            await Task.Delay(500);
            return txt != _input.Text;
        }}
        _input.TextChanged += async (_, _) =>
        {{
            if (await UserKeepsTyping()) return;
            (({viewModelName})BindingContext).ValidateDirtyProperty(
                ""{property.Name}"", _input.Text is not null && _input.Text.Length > 0);
        }};

        // numeric fields, subscribe to the Validating event, then it tries to parse the input
        // if it fails, it adds a validation error
        BindingContextChanged += (_, _) => Subscribe();
        Subscribe();

        var validationLabel = new {Controls.GetValidationClassName()}();{Controls.SetValidationTextColor("validationLabel")}
        {Controls.GetValidationRef("validationLabel")}
            .Bind(
                Label.TextProperty,
                getter: static ({viewModelName} vm) => vm.{property.Name}Error);

        Children.Add(label);
        Children.Add(_input);
        Children.Add(validationLabel);
    }}

    private void Subscribe()
    {{
        var vm = BindingContext as {viewModelName};

        var vmChanged = _subscribedTo != vm;
        if (!vmChanged) return;

        if (_subscribedTo is not null)
            _subscribedTo.Validating -= OnValidating;

        if (vm is not null)
            vm.Validating += OnValidating;

        _subscribedTo = vm;
    }}

    private void OnValidating({viewModelName} vm, EntityViews.Attributes.ValidatingEventArgs args)
    {{
        if (args.PropertyName is not null && args.PropertyName != ""{property.Name}"") return;
        if (string.IsNullOrWhiteSpace(_input.Text)) return;
        if (!{property.Type.Name}.TryParse(_input.Text, out _))
            vm.AddValidationError(
                ""{property.Name}"",
                string.Format(
                    EntityViews.Attributes.SpecialValidationMessages.ValidNumber, _input.Text, ""{property.Name}""));
    }}
}}
";
    }
}
